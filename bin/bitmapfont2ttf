#!/usr/bin/env fontforge
# -*- mode: python; coding: utf-8 -*-

import fontforge
import os
import shutil
import sys
import argparse
import re
import collections

# thanks https://stackoverflow.com/questions/5226958/which-equivalent-function-in-python
def which(file_name):
    for path in os.environ["PATH"].split(os.pathsep):
        full_path = os.path.join(path, file_name)
        if os.path.exists(full_path) and os.access(full_path, os.X_OK):
            return full_path
    return None

def bdfParseLine(line):
    words = []
    line = line.strip()
    while True:
        match = re.match(r'^\s*"((?:[^"]+|"")*)"($|\s+)', line)
        if match:
            word = match.group(1) # $1
            word = re.sub(r'""', '"', word)
            words.append(word)
            line = line[len(match.group(0)):] # $'
            continue
        match = re.match(r'^\s*(\S+)($|\s+)', line)
        if match:
            word = match.group(1) # $1
            words.append(word)
            line = line[len(match.group(0)):] # $'
            continue
        break
    return words

# FOR: keep track of all BDF properties
def bdfParseLine2(line):
    match = re.match(r'^\s*(\S+)(?:\s+)(\S.*?)\s*$', line)
    if match:
        key = match.group(1)
        value = match.group(2)
        return [key, value]
    match = re.match(r'^\s*(\S+)', line)
    if match:
        key = match.group(1);
        return [match.group(1), None]
    return None

class MyBDFChar:
    def __init__(self, name = None, font = None):
        self.name = name

        # ENCODING
        self.encoding = None
        self.nonStandardEncoding = None

        # BBX
        self.hasBoundingBox = False
        self.boundingBoxX = None
        self.boundingBoxY = None
        self.boundingBoxXOffset = None
        self.boundingBoxYOffset = None

        # SWIDTH
        self.scalableWidthX = None
        self.scalableWidthY = None

        # DWIDTH
        self.devicePixelWidthX = None
        self.devicePixelWidthY = None

        # SWIDTH1
        self.scalableWidthWritingMode1X = None
        self.scalableWidthWritingMode1Y = None

        # DWIDTH1
        self.devicePixelWidthWritingMode1X = None
        self.devicePixelWidthWritingMode1Y = None

    def __str__(self):
        result = "<MyBDFChar"
        if self.name != None:
            result += (" %s" % self.name)
        if self.encoding != None:
            result += (" @%d" % self.encoding)
        if self.nonStandardEncoding != None:
            result += (" @[%d]" % self.nonStandardEncoding)
        if self.hasBoundingBox:
            result += (" [%g, %g offset %g, %g]" % (
                self.boundingBoxX, self.boundingBoxY,
                self.boundingBoxXOffset, self.boundingBoxYOffset
            ))
        result += ">"
        return result

    def swidthX(self):
        if self.scalableWidthX != None:
            return self.scalableWidthX
        if self.devicePixelWidthX != None:
            return self.devicePixelWidthX / 72000.0 * self.resolutionX() * self.font.pointSize()
        return self.font.swidthX()

    def swidthY(self):
        if self.scalableWidthY != None:
            return self.scalableWidthY
        if self.devicePixelWidthY != None:
            return self.devicePixelWidthY / 72000.0 * self.resolutionY() * self.font.pointSize()
        return self.font.swidthY()

    def dwidthX(self):
        if self.devicePixelWidthX != None:
            return self.devicePixelWidthX
        if self.scalableWidthX != None:
            return int(round(self.scalableWidthX * 72000.0 / self.resolutionX() / self.font.pointSize()))
        return self.font.dwidthX()

    def dwidthY(self):
        if self.devicePixelWidthY != None:
            return self.devicePixelWidthY
        if self.scalableWidthY != None:
            return int(round(self.scalableWidthY * 72000.0 / self.resolutionY() / self.font.pointSize()))
        return self.font.dwidthY()

    def resolutionX(self):
        return self.font.resolutionX()

    def resolutionY(self):
        return self.font.resolutionY()

class MyBDF:
    def __init__(self, filename = None):

        # SIZE
        self.pointSize = None
        self.xRes = None
        self.yRes = None

        # FONTBOUNDINGBOX
        self.hasBoundingBox = False
        self.boundingBoxX = None
        self.boundingBoxY = None
        self.boundingBoxXOffset = None
        self.boundingBoxYOffset = None

        # METRICSSET
        self.metricsSet = None

        # SWIDTH
        self.scalableWidthX = None
        self.scalableWidthY = None

        # DWIDTH
        self.devicePixelWidthX = None
        self.devicePixelWidthY = None

        # SWIDTH1
        self.scalableWidthWritingMode1X = None
        self.scalableWidthWritingMode1Y = None

        # DWIDTH1
        self.devicePixelWidthWritingMode1X = None
        self.devicePixelWidthWritingMode1Y = None

        # STARTPROPERTIES .. ENDPROPERTIES
        self.properties = {}
        self.properties["pixelSize"] = None      # PIXEL_SIZE
        self.properties["pointSize10"] = None    # POINT_SIZE
        self.properties["resolutionX"] = None    # RESOLUTION_X
        self.properties["resolutionY"] = None    # RESOLUTION_Y
        self.properties["spacing"] = None        # SPACING ('M' for monospace or 'C' for character-cell fonts)
        self.properties["capHeight"] = None      # CAP_HEIGHT
        self.properties["xHeight"] = None        # X_HEIGHT
        self.properties["ascent"] = None         # FONT_ASCENT
        self.properties["descent"] = None        # FONT_DESCENT
        self.properties["averageWidth10"] = None # AVERAGE_WIDTH
        
        # FOR: keep track of all BDF properties
        self.bdfProperties = {}
        self.bdfArrayProperties = {}

        self.filename = None
        self.chars = []
        self.charsByEncoding = {}
        self.charsByNonStandardEncoding = {}
        self.charsByName = {}

        self.fillBoundingBoxWidth = False

        if filename != None:
            self.read(filename)

    def swidthX(self):
        if self.scalableWidthX != None:
            return self.scalableWidthX
        if self.devicePixelWidthX != None:
            return self.devicePixelWidthX / 72000.0 * self.resolutionX() * self.pointSize()
        raise Exception('cannot determine swidthX')

    def swidthY(self):
        if self.scalableWidthY != None:
            return self.scalableWidthY
        if self.devicePixelWidthY != None:
            return self.devicePixelWidthY / 72000.0 * self.resolutionY() * self.pointSize()
        raise Exception('cannot determine swidthY')

    def dwidthX(self):
        if self.devicePixelWidthX != None:
            return self.devicePixelWidthX
        if self.scalableWidthX != None:
            return int(round(self.scalableWidthX * 72000.0 / self.resolutionX() / self.pointSize()))
        raise Exception('cannot determine dwidthX')

    def dwidthY(self):
        if self.devicePixelWidthY != None:
            return self.devicePixelWidthY
        if self.scalableWidthY != None:
            return int(round(self.scalableWidthY * 72000.0 / self.resolutionY() / self.pointSize()))
        raise Exception('cannot determine dwidthY')

    def pointSize(self):
        pt10 = self.properties['pointSize10']
        if pt10 != None:
            return pt10 / 10.0
        px = self.properties['pixelSize']
        if px != None:
            return 72.0 * px / self.resolutionY()
        raise Exception('cannot determine pointSize')

    def pixelSize(self):
        px = self.properties['pixelSize']
        if px != None:
            return px
        pt10 = self.properties['pointSize10']
        if pt10 != None:
            return pt10 / 720.0 * self.resolutionY()
        raise Exception('cannot determine pixelSize')

    def resolutionX(self):
        r = self.properties['resolutionX']
        if r != None:
            return r
        raise Exception('cannot determine resolutionX')

    def resolutionY(self):
        r = self.properties['resolutionY']
        if r != None:
            return r
        raise Exception('cannot determine resolutionY')

    def ascentPx(self):
        ascent = self.properties['ascent']
        if ascent != None:
            return ascent
        raise Exception('cannot determine ascentPx')

    def descentPx(self):
        bby = self.boundingBoxY
        ascent = self.properties['ascent']
        if bby != None and ascent != None:
            return bby - ascent
        raise Exception('cannot determine descentPx')

    def read(self, filename):
        with open(filename) as fp:
            self.filename = filename
            self.readFp(fp)

    def readFp(self, fp):
        for line in fp:
            args = bdfParseLine(line)
            if len(args) < 1:
                continue
            (cmd, args) = (args[0].upper(), args[1:])
            if cmd == 'CHARS':
                self.readCharsFp(fp)
            if cmd == 'SIZE' and len(args) >= 3:
                self.pointSize = float(args[0]) # point size of the glyphs
                self.xRes      = float(args[1]) # x resolution of the device for which the font is intended
                self.yRes      = float(args[2]) # y resolution "  "   "      "   "     "   "    "  "
                continue
            if cmd == 'FONTBOUNDINGBOX' and len(args) >= 4:
                self.hasBoundingBox = True
                self.boundingBoxX       = int(args[0]) # integer pixel values, offsets relative to origin
                self.boundingBoxY       = int(args[1])
                self.boundingBoxXOffset = int(args[2])
                self.boundingBoxYOffset = int(args[3])
                continue
            if cmd == 'METRICSSET' and len(args) >= 1:
                self.metricsSet = int(args[0])
            if cmd == 'SWIDTH':
                self.scalableWidthX = float(args[0])
                self.scalableWidthY = float(args[1])
            if cmd == 'DWIDTH':
                self.devicePixelWidthX = float(args[0])
                self.devicePixelWidthY = float(args[1])
            if cmd == 'SWIDTH1':
                self.scalableWidthWritingMode1X = float(args[0])
                self.scalableWidthWritingMode1Y = float(args[1])
            if cmd == 'DWIDTH1':
                self.devicePixelWidthWritingMode1X = float(args[0])
                self.devicePixelWidthWritingMode1Y = float(args[1])
            if cmd == 'VVECTOR':
                sys.stderr.write("bitmapfont2ttf: %s: fonts with VVECTOR not supported yet.\n" % self.args.full_name)
                exit(1)
            if cmd == 'STARTPROPERTIES':
                self.readPropertiesFp(fp)

    def readPropertiesFp(self, fp):
        for line in fp:
            args = bdfParseLine(line)
            if len(args) < 1:
                continue
            (cmd, args) = (args[0].upper(), args[1:])
            if cmd == 'ENDPROPERTIES':
                return
            if cmd == 'PIXEL_SIZE' and len(args) >= 1:
                self.properties["pixelSize"] = float(args[0])
            if cmd == 'POINT_SIZE' and len(args) >= 1:
                self.properties["pointSize10"] = float(args[0])
            if cmd == 'RESOLUTION_X' and len(args) >= 1:
                self.properties["resolutionX"] = float(args[0])
            if cmd == 'RESOLUTION_Y' and len(args) >= 1:
                self.properties["resolutionY"] = float(args[0])
            if cmd == 'SPACING' and len(args) >= 1:
                self.properties["spacing"] = args[0].upper()
            if cmd == 'CAP_HEIGHT' and len(args) >= 1:
                self.properties["capHeight"] = float(args[0])
            if cmd == 'X_HEIGHT' and len(args) >= 1:
                self.properties["xHeight"] = float(args[0])
            if cmd == 'FONT_ASCENT' and len(args) >= 1:
                self.properties["ascent"] = float(args[0])
            if cmd == 'FONT_DESCENT' and len(args) >= 1:
                self.properties["descent"] = float(args[0])
            if cmd == 'AVERAGE_WIDTH' and len(args) >= 1:
                self.properties["averageWidth10"] = float(args[0])

            # FOR: keep track of all BDF properties
            result = bdfParseLine2(line)
            if result:
                key = result[0]
                value = result[1]
                self.addBdfProperty(key, value)

    # FOR: keep track of all BDF properties
    def addBdfProperty(self, key, value):
        self.bdfProperties[key] = value
        if self.bdfArrayProperties.get(key) == None:
            self.bdfArrayProperties[key] = []
        self.bdfArrayProperties[key].append(value)

    def readCharsFp(self, fp):
        for line in fp:
            args = bdfParseLine(line)
            if len(args) < 1:
                continue
            (cmd, args) = (args[0].upper(), args[1:])
            if cmd == 'STARTCHAR':
                char = self.readCharFp(fp, args[0])
                self.chars.append(char)
                if char.encoding != None:
                    self.charsByEncoding[char.encoding] = char
                if char.nonStandardEncoding != None:
                    self.charsByEncoding[char.nonStandardEncoding] = char
                if char.name != None:
                    self.charsByName[char.name] = char

    def readBitmapDataFp(self, fp):
        bitmapData = []
        for line in fp:
            if re.match(r'^\s*ENDCHAR\s*$', line, flags = re.IGNORECASE):
                break
            bitmapData.append(line.strip())
        numBits = max(len(s) * 4 for s in bitmapData)
        bitmapData = [bin(int(s, 16))[2:].rjust(numBits, '0') for s in bitmapData]
        return bitmapData

    def readCharFp(self, fp, name):
        char = MyBDFChar(name = name, font = self)
        for line in fp:
            args = bdfParseLine(line)
            if len(args) < 1:
                continue
            (cmd, args) = (args[0].upper(), args[1:])
            if cmd == 'BITMAP':
                char.bitmapData = self.readBitmapDataFp(fp)
                return char
            elif cmd == 'ENDCHAR':
                return char
            elif cmd == 'ENCODING':
                char.encoding = int(args[0])
                if len(args) > 1:
                    char.nonStandardEncoding = int(args[1])
                if char.encoding == -1:
                    char.encoding = None
            elif cmd == 'BBX':
                char.hasBoundingBox = True
                char.boundingBoxX       = int(args[0])
                char.boundingBoxY       = int(args[1])
                char.boundingBoxXOffset = int(args[2])
                char.boundingBoxYOffset = int(args[3])
            elif cmd == 'SWIDTH':
                char.scalableWidthX = float(args[0])
                char.scalableWidthY = float(args[1])
            elif cmd == 'DWIDTH':
                char.devicePixelWidthX = int(args[0])
                char.devicePixelWidthY = int(args[1])
            elif cmd == 'SWIDTH1':
                char.scalableWidthWritingMode1X = float(args[0])
                char.scalableWidthWritingMode1Y = float(args[1])
            elif cmd == 'DWIDTH1':
                char.devicePixelWidthWritingMode1X = int(args[0])
                char.devicePixelWidthWritingMode1Y = int(args[1])
            elif cmd == 'VVECTOR':
                sys.stderr.write("bitmapfont2ttf: %s: fonts with VVECTOR not supported yet.\n" % self.args.full_name)
                exit(1)

    def scalableToPixels(self, scalable):
        return 1.0 * scalable * self.properties["pixelSize"] / 1000.0
    def scalableToPixelsX(self, scalable):
        return 1.0 * scalable * self.properties["pixelSize"] / 1000.0 / self.aspectRatioXtoY()

    def pixelsToScalable(self, pixels):
        return 1.0 * pixels * 1000.0 / self.properties["pixelSize"]
    def pixelsToScalableX(self, pixels):
        return 1.0 * pixels * 1000.0 / self.properties["pixelSize"] * self.aspectRatioXtoY()

    # less than 1 means taller than wide; greater than 1 means wider than tall
    def aspectRatioXtoY(self):
        return 1.0 * self.properties["resolutionY"] / self.properties["resolutionX"]

    def __str__(self):
        result = "<MyBDF"
        if self.filename != None:
            result += (" %s" % self.filename)
        if self.pointSize != None:
            result += (" %gpt" % self.pointSize)
        if self.xRes != None:
            result += (" %gxdpi" % self.xRes)
        if self.yRes != None:
            result += (" %gydpi" % self.yRes)
        if self.hasBoundingBox:
            result += (" [%g, %g offset %g, %g]" % (
                self.boundingBoxX, self.boundingBoxY,
                self.boundingBoxXOffset, self.boundingBoxYOffset
            ))
        result += ">"
        return result

class BitmapFont2TTF:
    def __init__(self, args):
        self.setArgs(args)
        self.fixFilenames()

    # nearestMultipleOfFour = False
    # nextMultipleOfFour = False
    # specifiedPixelSize = None
    # asciiOnly = False
    # filename = None
    # destfilename = None
    # verbose = 0
    # filename = None
    # destfilename = None
    # args = None
    # metricsAscent = None
    # metricsDescent = None
    # metricsLineHeight = None

    def setArgs(self, args):
        self.args = args
        self.filename = args.filename
        self.destfilenames = args.destfilenames
        # self.nearestMultipleOfFour = False
        # self.nextMultipleOfFour = False
        # self.specifiedPixelSize = None
        # self.asciiOnly = False
        # self.useOwnBitmapTracing = False
        # self.verbose = 0
        # self.dotWidth = 1
        # self.dotHeight = 1
        # if args.nearest_multiple_of_four:
        #     self.nearestMultipleOfFour = args.nearest_multiple_of_four
        # if args.next_multiple_of_four:
        #     self.nextMultipleOfFour = args.next_multiple_of_four
        # if args.ascii_only:
        #     self.asciiOnly = args.ascii_only
        # if args.verbose:
        #     self.verbose = args.verbose
        # if args.pixel_size:
        #     self.specifiedPixelSize = args.pixel_size
        # if args.ascent:
        #     self.metricsAscent = args.ascent
        # if args.descent:
        #     self.metricsDescent = args.descent
        # if args.line_height:
        #     self.metricsLineHeight = args.line_height
        # if args.use_own_bitmap_tracing:
        #     self.useOwnBitmapTracing = True
        # if args.dot_width:
        #     self.useOwnBitmapTracing = True
        #     self.dotWidth = args.dot_width
        # if args.dot_height:
        #     self.useOwnBitmapTracing = True
        #     self.dotHeight = args.dot_height
        # if args.fill_bounding_box_width:
        #     self.fillBoundingBoxWidth = True

    def fixFilenames(self):
        if self.filename == os.path.basename(self.filename):
            # Work around an issue where importBitmaps segfaults if you only
            # specify a filename 'foo.pcf'.  Yes, './foo.pcf' works pefectly
            # fine whereas 'foo.pcf' does not.
            self.filename = os.path.join('.', self.filename)

        if self.destfilenames == None or len(self.destfilenames) == 0:
            (rootdestfilename, junk) = os.path.splitext(self.filename)
            self.destfilenames = [rootdestfilename + '.ttf']

    # NOT IN USE
    def fixMissingGlyphs(self):
        self.fixMissingGlyph(39, 8217) # U+0027 APOSTROPHE;   U+2019 RIGHT SINGLE QUOTATION MARK
        self.fixMissingGlyph(45, 8722) # U+002D HYPHEN-MINUS; U+2212 MINUS SIGN
        self.fixMissingGlyph(96, 8216) # U+0060 GRAVE;        U+2018 LEFT SINGLE QUOTATION MARK

    # NOT IN USE
    def fixMissingGlyph(self, destUni, sourceUni):
        hasSource = False
        hasDest = False
        sourceGlyph = None
        destGlyph = None
        self.font.selection.select(('unicode', None), sourceUni)
        for glyph in self.font.selection.byGlyphs:
            sourceGlyph = glyph
            hasSource = True
            break
        self.font.selection.select(('unicode', None), destUni)
        for glyph in self.font.selection.byGlyphs:
            hasDest = True
            break
        if hasSource and not hasDest:
            destGlyph = self.font.createChar(destUni)
            self.font.selection.select(sourceGlyph)
            self.font.copy()
            self.font.selection.select(destGlyph)
            self.font.paste()

    # NOT IN USE
    def autoTrace(self):
        glyphCount = self.getGlyphCount()

        sys.stderr.write("bitmapfont2ttf: %s: tracing %d glyphs...\n" % (self.args.full_name, glyphCount))

        glyphIndex = 0
        for glyph in self.font.glyphs():
            if self.asciiOnly and (glyph.encoding < 32 or glyph.encoding > 126):
                continue
            glyphIndex += 1
            if self.verbose >= 2:
                sys.stderr.write("bitmapfont2ttf: %s: [%d/%d] %s\r" % (self.args.full_name, glyphIndex, glyphCount, glyph))
            elif self.verbose >= 1:
                sys.stderr.write("bitmapfont2ttf: %s: [%d/%d]\r" % (self.args.full_name, glyphIndex, glyphCount))
            if self.useOwnBitmapTracing:
                self.traceGlyph(glyph)
            else:
                glyph.autoTrace()
            glyph.addExtrema()
            glyph.simplify()

            # this is not true for lucida typewriter fonts
            # if glyph.swidth:
            #     glyph.width = glyph.swidth
            # elif self.swidth:
            #     glyph.width = self.swidth

            bdfChar = None
            if glyph.encoding in self.bdf.charsByEncoding:
                bdfChar = self.bdf.charsByEncoding[glyph.encoding]

            oldWidth = glyph.width
            newWidth = None
            if bdfChar:
                if bdfChar.devicePixelWidthX:
                    newWidth = round(
                        self.bdf.pixelsToScalableX(bdfChar.devicePixelWidthX) / 1000.0 * self.font.em
                    )
                elif bdfChar.scalableWidthX:
                    newWidth = round(
                        bdfChar.scalableWidthX / 1000.0 * self.font.em
                    )

            if newWidth != None and abs(newWidth - oldWidth) > 1:
                glyph.width = newWidth
                if os.getenv("BITMAPFONT2TTF_DEBUG"):
                    sys.stderr.write("bitmapfont2ttf: %s: U+%04X: swidth = %s; dwidthx = %s; glyph.width = %s => %s\n" % (
                        self.args.full_name,
                        glyph.encoding,
                        self.swidth,
                        bdfChar.devicePixelWidthX,
                        oldWidth,
                        glyph.width
                    ))

    # NOT IN USE
    def adjustGlyphSizes(self):
        if self.bdf.fillBoundingBoxWidth:
            for glyph in self.font.glyphs():
                oldWidth = glyph.width
                if self.bdf.properties["resolutionX"] and self.bdf.properties["resolutionY"]:
                    newWidth = 1.0 * self.font.em / self.bdf.properties["pixelSize"] * self.bdf.boundingBoxX * self.bdf.aspectRatioXtoY()
                else:
                    newWidth = 1.0 * self.font.em / self.bdf.properties["pixelSize"] * self.bdf.boundingBoxX
                    raise Exception("neither resolutionX nor resolutionY defined")
                print("oldWidth = %f; newWidth = %f" % (oldWidth, newWidth))
                glyph.transform(psMat.translate((newWidth - oldWidth) / 2, 0))
                glyph.width = newWidth
        if self.finalPixelSize != self.pixelSize:
            sys.stderr.write("bitmapfont2ttf: %s: adjusting pixel size from %d to %d\n" % (self.args.full_name, self.pixelSize, self.finalPixelSize))
            for glyph in self.font.glyphs():
                glyph.transform(psMat.scale(1.0 * self.pixelSize / self.finalPixelSize))

    def traceGlyph(self, glyph, bdfChar):
        y = bdfChar.boundingBoxYOffset + bdfChar.boundingBoxY
        pixY = 1.0 * self.font.em / self.bdf.pixelSize()
        pixX = 1.0 * self.font.em / self.bdf.pixelSize() * self.bdf.aspectRatioXtoY()
        for line in bdfChar.bitmapData:
            y = y - 1
            x = bdfChar.boundingBoxXOffset
            deltaX = 0
            deltaY = 0
            # deltaX = pixX * (1 - self.dotWidth) / 2
            # deltaY = pixY * (1 - self.dotHeight) / 2
            for pixel in line:
                if pixel == '1':
                    x1 = pixX * x       + deltaX
                    x2 = pixX * (x + 1) - deltaX
                    y1 = pixY * y       + deltaY
                    y2 = pixY * (y + 1) - deltaY
                    contour = fontforge.contour()
                    contour.moveTo(x1, y1)
                    contour.lineTo(x1, y2)
                    contour.lineTo(x2, y2)
                    contour.lineTo(x2, y1)
                    contour.closed = True
                    glyph.layers['Fore'] += contour
                x = x + 1
        glyph.width = int(round(bdfChar.dwidthX() * pixX))

    def trace(self):
        count = len(self.bdf.chars)
        index = 0
        for char in self.bdf.chars:
            index = index + 1
            sys.stderr.write('  %d/%d glyphs...\r' % (index, count))
            encoding = char.encoding if char.encoding else -1
            try:
                glyph = self.font.createChar(encoding, char.name)
            except:
                sys.stderr.write('\nencoding %s; name %s\n' % (encoding, char.name))
                raise
            self.traceGlyph(glyph, char)
            glyph.addExtrema()
            glyph.simplify()
        sys.stderr.write('  %d/%d glyphs done!\n' % (count, count))

    # NOT IN USE
    def getGlyphCount(self):
        glyphCount = 0
        for glyph in self.font.glyphs():
            if self.asciiOnly and (glyph.encoding < 32 or glyph.encoding > 126):
                continue
            glyphCount += 1
        return glyphCount

    def loadBDF(self):
        if not re.search(r'\.bdf$', self.filename):
            raise Exception("only bdfs are supported")
        self.bdf = MyBDF(self.filename)

    def setPropertiesFromBDF(self):
        self.isMonospace = self.bdf.properties["spacing"] == 'M' or self.bdf.properties["spacing"] == 'C'
        self.pixelSize = self.bdf.properties["pixelSize"]
        if not self.pixelSize:
            if self.bdf.boundingBoxY:
                self.pixelSize = self.bdf.boundingBoxY
        # self.finalPixelSize = self.pixelSize
        # if self.specifiedPixelSize:
        #     self.finalPixelSize = 4 * int((self.specifiedPixelSize + 2) / 4)
        # elif self.nextMultipleOfFour:
        #     self.finalPixelSize = 4 * int((self.pixelSize + 3) / 4)
        # elif self.nearestMultipleOfFour:
        #     self.finalPixelSize = 4 * int((self.pixelSize + 2) / 4)

    def setFontMetas(self):
        if self.args != None:
            if self.args.copyright != None:
                self.font.copyright = self.args.copyright
            if self.args.comment != None:
                self.font.comment = self.args.comment
            if self.args.font_name != None:
                self.font.fontname = self.args.font_name
            if self.args.family_name != None:
                self.font.familyname = self.args.family_name
            if self.args.full_name != None:
                self.font.fullname = self.args.full_name
            if self.args.version != None:
                self.font.version = self.args.version
            if self.args.weight != None:
                self.font.weight = self.args.weight
            if self.args.italic_angle != None:
                self.font.italicangle = self.args.italic_angle

    def save(self):
        for dest in self.destfilenames:
            if re.search(r'\.sfd$', dest):
                self.font.save(dest)
            else:
                self.font.generate(dest)
            sys.stderr.write("bitmapfont2ttf: %s: Wrote %s\n" % (self.args.full_name, dest))

    def setSwidth(self):
        if self.isMonospace:
            self.swidthPx = self.bdf.boundingBoxX
            self.swidthEm = 1.0 * self.swidthPx / self.pixelSize
        else:
            self.swidthPx = None
            self.swidthEm = None
        if False:
            if self.isMonospace:
                self.swidth = int(0.5 + 1.0 * self.font.em * self.bdf.boundingBoxX / self.pixelSizeX())
                if os.getenv("BITMAPFONT2TTF_DEBUG"):
                    sys.stderr.write("bitmapfont2ttf: %s: setWidth:\n" % self.args.full_name)
                    sys.stderr.write("    setting font swidth to %s\n" % self.swidth)
                    sys.stderr.write("    self.font.em = %s\n" % self.font.em)
                    sys.stderr.write("    self.bdf.boundingBoxX = %s\n" % self.bdf.boundingBoxX)
                    sys.stderr.write("    self.pixelSize = %s\n" % self.pixelSize)
            else:
                self.swidth = None
                if os.getenv("BITMAPFONT2TTF_DEBUG"):
                    sys.stderr.write("bitmapfont2ttf: %s: setSwidth: no font swidth\n" % self.args.full_name)

    def setInitialAscentDescent(self):
        self.descentPx = self.bdf.descentPx()
        self.ascentPx  = self.bdf.ascentPx()
        self.descentEm = 1.0 * self.descentPx / self.pixelSize
        self.ascentEm  = 1.0 * self.ascentPx  / self.pixelSize
        ascent  = round(self.ascentEm * self.font.em)
        descent = round(self.descentEm * self.font.em)
        # self.descentPx = self.pixelSize - self.bdf.properties["ascent"]
        # self.ascentPx = self.bdf.properties["ascent"]
        # # must be specified before bitmap import for baseline alignment
        # em = self.font.em
        # ascent  = int(0.5 + 1.0 * em * self.ascentPx  / self.pixelSize)
        # descent = int(0.5 + 1.0 * em * self.descentPx / self.pixelSize)
        self.font.ascent  = ascent
        self.font.descent = descent

    def setItalic(self):
        self.isItalic = (re.search(r'\b(italic|oblique)\b', self.font.fontname, flags = re.IGNORECASE) or
                         re.search(r'\b(italic|oblique)\b', self.font.fullname, flags = re.IGNORECASE) or
                         (self.args.font_name   != None and re.search(r'\b(italic|oblique)\b', self.args.font_name,   flags = re.IGNORECASE)) or
                         (self.args.family_name != None and re.search(r'\b(italic|oblique)\b', self.args.family_name, flags = re.IGNORECASE)))
        if self.isItalic:
            self.font.italicangle = 15
        else:
            self.font.italicangle = 0

    def setWeight(self):
        if self.font.weight == 'Regular' or self.font.weight == 'Medium' or self.font.weight == 'Book':
            self.font.weight = 'Book'
            self.font.os2_weight = 400
            if self.isItalic:
                self.font.os2_stylemap |= 0x0201
                self.font.macstyle     |= 0x0002
            else:
                self.font.os2_stylemap |= 0x0040
                self.font.macstyle     |= 0x0000
        elif self.font.weight == 'Bold':
            self.font.weight = 'Bold'
            self.font.os2_weight = 700
            if self.isItalic:
                self.font.os2_stylemap |= 0x0221
                self.font.macstyle     |= 0x0003
            else:
                self.font.os2_stylemap |= 0x0020
                self.font.macstyle     |= 0x0001

    # NOT IN USE
    def useFinalPixelSize(self):
        if self.finalPixelSize != self.pixelSize:
            if self.finalPixelSize > self.pixelSize:
                diff = self.finalPixelSize - self.pixelSize # 1, 2, 3, ...
                diff1 = int(diff) / 2 # 1 => 0, 2 => 1, 3 => 1, 4 => 2, ...
                diff2 = diff - diff1  # 1 => 1, 2 => 1, 3 => 2, 4 => 2, ...
                self.ascentPx += diff2
                self.descentPx += diff1
            else:
                diff = self.pixelSize - self.finalPixelSize # 1, 2, 3, ...
                diff1 = int(diff) / 2 # 1 => 0, 2 => 1, 3 => 1, 4 => 2, ...
                diff2 = diff - diff1  # 1 => 1, 2 => 1, 3 => 2, 4 => 2, ...
                self.ascentPx -= diff2
                self.descentPx -= diff1
            em = self.font.em
            self.font.ascent  = int(0.5 + 1.0 * em * self.ascentPx  / self.finalPixelSize)
            self.font.descent = int(0.5 + 1.0 * em * self.descentPx / self.finalPixelSize)

    # NOT IN USE
    def setFinalMetrics(self):
        ascent  = self.font.ascent
        descent = self.font.descent

        # if self.metricsAscent != None: # --ascent
        #     ascent = self.metricsAscent
        # if self.metricsDescent != None: # --descent
        #     descent = self.metricsDescent
        # if self.metricsLineHeight != None:                           # --line-height, e.g., 1.1
        #     height      = self.font.em                               # e.g., 2048
        #     finalHeight = int(0.5 + self.metricsLineHeight * height) # e.g., 2253
        #     add         = finalHeight - height                       # e.g., 205
        #     addAscent   = int(0.5 + 1.0 * add / 2)                   # e.g., 103
        #     addDescent  = add - addAscent                            # e.g., 102
        #     ascent      = self.font.ascent + addAscent
        #     descent     = self.font.descent + addDescent

        self.font.hhea_ascent_add     = 0
        self.font.hhea_descent_add    = 0
        self.font.os2_typoascent_add  = 0
        self.font.os2_typodescent_add = 0
        self.font.os2_winascent_add   = 0
        self.font.os2_windescent_add  = 0

        self.font.ascent          = ascent
        self.font.descent         = descent
        self.font.hhea_ascent     = ascent
        self.font.hhea_descent    = -descent
        self.font.hhea_linegap    = 0
        self.font.os2_typoascent  = ascent
        self.font.os2_typodescent = -descent
        self.font.os2_typolinegap = 0
        self.font.os2_winascent   = ascent
        self.font.os2_windescent  = descent

    def bitmapfont2ttf(self):
        # self.setArgs(args)
        # self.fixFilenames()
        self.loadBDF()
        self.setPropertiesFromBDF()
        self.font = fontforge.font()
        self.setSwidth()
        self.setInitialAscentDescent()
        self.font.importBitmaps(self.filename, True)
        self.font.os2_vendor = 'PfEd'
        self.font.encoding = 'iso10646-1'
        self.setItalic()
        self.setWeight()
        # self.useFinalPixelSize()
        self.setFontMetas()
        # self.autoTrace()
        # self.adjustGlyphSizes()
        # self.fixMissingGlyphs()
        self.trace()
        self.setFinalMetrics()
        self.save()

parser = argparse.ArgumentParser(description = "Generate TTF files from bitmap fonts, e.g., BDF and PCF")
parser.add_argument("--copyright",                help = "assign copyright holder and date, e.g., 'Copyright (c) 2020 Darren Embry'")
parser.add_argument("--comment",                  help = "assign comment string, e.g., '2020-01-01'")
parser.add_argument("--family-name",              help = "assign family name, e.g., 'Comic Sans'")
parser.add_argument("--font-name",                help = "assign font name, e.g., 'ComicSansBoldItalic'")
parser.add_argument("--full-name",                help = "assign full name, e.g., 'Comic Sans Bold Italic'")
parser.add_argument("--version",                  help = "assign version, e.g., '001.000'")
parser.add_argument("--weight",                   help = "assign font weight, e.g., 'Regular', 'Bold'")
parser.add_argument("--italic-angle",             type = float, help = "assign font italic angle, e.g., -22.5")
parser.add_argument("--save-sfd",                 help = "keep .sfd file (for FontForge)", action = "store_true")
parser.add_argument("--verbose", "-v",            action = 'count', help = "increase output verbosity")
parser.add_argument("--nearest-multiple-of-four", action = 'store_true')
parser.add_argument("--next-multiple-of-four",    action = 'store_true')
parser.add_argument("--pixel-size",               type = int, help = "pixel font size in mult. of 4")
parser.add_argument("--ascii-only",               action = 'store_true')
parser.add_argument("--sfd-dir",                  type = str)
parser.add_argument("--ascent",                   type = int, help = "ascent for metrics, positive above baseline, e.g., 1853")
parser.add_argument("--descent",                  type = int, help = "descent for metrics, positive below baseline, e.g., 605")
parser.add_argument("--line-height",              type = float, help = "line height to use for final metrics, e.g., 1.2")
parser.add_argument("--use-own-bitmap-tracing",   action = 'store_true')
parser.add_argument("--dot-width",                type = float, help = 'width  of each dot as multiple of pixel width,  e.g., 0.9')
parser.add_argument("--dot-height",               type = float, help = 'height "  "    "   "  "        "  "     height, e.g., 0.9')
parser.add_argument("--fill-bounding-box-width",  action = 'store_true')
parser.add_argument("filename")
parser.add_argument("destfilenames",               nargs = '*')

args = parser.parse_args()
bf2ttf = BitmapFont2TTF(args)
bf2ttf.bitmapfont2ttf()
